<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>インラインアセンブリ - Rust By Example 日本語版</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust concepts and standard libraries.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../css/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../index.html">Introduction</a></li><li class="chapter-item "><a href="../hello.html"><strong aria-hidden="true">1.</strong> Hello World</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../hello/comment.html"><strong aria-hidden="true">1.1.</strong> コメント</a></li><li class="chapter-item "><a href="../hello/print.html"><strong aria-hidden="true">1.2.</strong> フォーマットしてプリント</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../hello/print/print_debug.html"><strong aria-hidden="true">1.2.1.</strong> デバッグ</a></li><li class="chapter-item "><a href="../hello/print/print_display.html"><strong aria-hidden="true">1.2.2.</strong> ディスプレイ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../hello/print/print_display/testcase_list.html"><strong aria-hidden="true">1.2.2.1.</strong> テストケース: リスト</a></li></ol></li><li class="chapter-item "><a href="../hello/print/fmt.html"><strong aria-hidden="true">1.2.3.</strong> フォーマット</a></li></ol></li></ol></li><li class="chapter-item "><a href="../primitives.html"><strong aria-hidden="true">2.</strong> 基本データ型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../primitives/literals.html"><strong aria-hidden="true">2.1.</strong> リテラルとオペレータ</a></li><li class="chapter-item "><a href="../primitives/tuples.html"><strong aria-hidden="true">2.2.</strong> タプル</a></li><li class="chapter-item "><a href="../primitives/array.html"><strong aria-hidden="true">2.3.</strong> 配列とスライス</a></li></ol></li><li class="chapter-item "><a href="../custom_types.html"><strong aria-hidden="true">3.</strong> カスタム型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> 構造体</a></li><li class="chapter-item "><a href="../custom_types/enum.html"><strong aria-hidden="true">3.2.</strong> 列挙型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../custom_types/enum/enum_use.html"><strong aria-hidden="true">3.2.1.</strong> use</a></li><li class="chapter-item "><a href="../custom_types/enum/c_like.html"><strong aria-hidden="true">3.2.2.</strong> C言語ライクな列挙型</a></li><li class="chapter-item "><a href="../custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> テストケース: 連結リスト</a></li></ol></li><li class="chapter-item "><a href="../custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> 定数</a></li></ol></li><li class="chapter-item "><a href="../variable_bindings.html"><strong aria-hidden="true">4.</strong> 変数束縛</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> ミュータビリティ</a></li><li class="chapter-item "><a href="../variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> スコープとシャドーイング</a></li><li class="chapter-item "><a href="../variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> 宣言</a></li><li class="chapter-item "><a href="../variable_bindings/freeze.html"><strong aria-hidden="true">4.4.</strong> 値の凍結</a></li></ol></li><li class="chapter-item "><a href="../types.html"><strong aria-hidden="true">5.</strong> 型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../types/cast.html"><strong aria-hidden="true">5.1.</strong> 型キャスト</a></li><li class="chapter-item "><a href="../types/literals.html"><strong aria-hidden="true">5.2.</strong> リテラル</a></li><li class="chapter-item "><a href="../types/inference.html"><strong aria-hidden="true">5.3.</strong> 型推論</a></li><li class="chapter-item "><a href="../types/alias.html"><strong aria-hidden="true">5.4.</strong> エイリアス</a></li></ol></li><li class="chapter-item "><a href="../conversion.html"><strong aria-hidden="true">6.</strong> 型変換</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> FromおよびInto</a></li><li class="chapter-item "><a href="../conversion/try_from_try_into.html"><strong aria-hidden="true">6.2.</strong> TryFromおよびTryInto</a></li><li class="chapter-item "><a href="../conversion/string.html"><strong aria-hidden="true">6.3.</strong> Stringとの型変換</a></li></ol></li><li class="chapter-item "><a href="../expression.html"><strong aria-hidden="true">7.</strong> 式</a></li><li class="chapter-item "><a href="../flow_control.html"><strong aria-hidden="true">8.</strong> 条件分岐</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li class="chapter-item "><a href="../flow_control/loop.html"><strong aria-hidden="true">8.2.</strong> loop</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> ネストとラベル</a></li><li class="chapter-item "><a href="../flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> loopが返す値</a></li></ol></li><li class="chapter-item "><a href="../flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while</a></li><li class="chapter-item "><a href="../flow_control/for.html"><strong aria-hidden="true">8.4.</strong> for と range</a></li><li class="chapter-item "><a href="../flow_control/match.html"><strong aria-hidden="true">8.5.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../flow_control/match/destructuring.html"><strong aria-hidden="true">8.5.1.</strong> デストラクト</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">8.5.1.1.</strong> タプル</a></li><li class="chapter-item "><a href="../flow_control/match/destructuring/destructure_slice.html"><strong aria-hidden="true">8.5.1.2.</strong> 配列とスライス</a></li><li class="chapter-item "><a href="../flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">8.5.1.3.</strong> 列挙型</a></li><li class="chapter-item "><a href="../flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">8.5.1.4.</strong> ポインタとref</a></li><li class="chapter-item "><a href="../flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">8.5.1.5.</strong> 構造体</a></li></ol></li><li class="chapter-item "><a href="../flow_control/match/guard.html"><strong aria-hidden="true">8.5.2.</strong> ガード</a></li><li class="chapter-item "><a href="../flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> バインディング</a></li></ol></li><li class="chapter-item "><a href="../flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li class="chapter-item "><a href="../flow_control/let_else.html"><strong aria-hidden="true">8.7.</strong> let-else</a></li><li class="chapter-item "><a href="../flow_control/while_let.html"><strong aria-hidden="true">8.8.</strong> while let</a></li></ol></li><li class="chapter-item "><a href="../fn.html"><strong aria-hidden="true">9.</strong> 関数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fn/methods.html"><strong aria-hidden="true">9.1.</strong> メソッド</a></li><li class="chapter-item "><a href="../fn/closures.html"><strong aria-hidden="true">9.2.</strong> クロージャ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fn/closures/capture.html"><strong aria-hidden="true">9.2.1.</strong> 要素の捕捉</a></li><li class="chapter-item "><a href="../fn/closures/input_parameters.html"><strong aria-hidden="true">9.2.2.</strong> 捕捉時の型推論</a></li><li class="chapter-item "><a href="../fn/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> クロージャを受け取る関数</a></li><li class="chapter-item "><a href="../fn/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> 関数を受け取る関数</a></li><li class="chapter-item "><a href="../fn/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> クロージャを返す関数</a></li><li class="chapter-item "><a href="../fn/closures/closure_examples.html"><strong aria-hidden="true">9.2.6.</strong> stdにおける使用例</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li class="chapter-item "><a href="../fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">9.2.6.2.</strong> Iterator::find</a></li></ol></li></ol></li><li class="chapter-item "><a href="../fn/hof.html"><strong aria-hidden="true">9.3.</strong> 高階関数</a></li><li class="chapter-item "><a href="../fn/diverging.html"><strong aria-hidden="true">9.4.</strong> 発散する関数</a></li></ol></li><li class="chapter-item "><a href="../mod.html"><strong aria-hidden="true">10.</strong> モジュール</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../mod/visibility.html"><strong aria-hidden="true">10.1.</strong> プライベートとパブリック</a></li><li class="chapter-item "><a href="../mod/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> 構造体の場合</a></li><li class="chapter-item "><a href="../mod/use.html"><strong aria-hidden="true">10.3.</strong> use宣言</a></li><li class="chapter-item "><a href="../mod/super.html"><strong aria-hidden="true">10.4.</strong> super と self</a></li><li class="chapter-item "><a href="../mod/split.html"><strong aria-hidden="true">10.5.</strong> ファイルの階層構造</a></li></ol></li><li class="chapter-item "><a href="../crates.html"><strong aria-hidden="true">11.</strong> クレート</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../crates/lib.html"><strong aria-hidden="true">11.1.</strong> ライブラリ</a></li><li class="chapter-item "><a href="../crates/using_lib.html"><strong aria-hidden="true">11.2.</strong> ライブラリの利用</a></li></ol></li><li class="chapter-item "><a href="../cargo.html"><strong aria-hidden="true">12.</strong> Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../cargo/deps.html"><strong aria-hidden="true">12.1.</strong> Dependencies</a></li><li class="chapter-item "><a href="../cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> Conventions</a></li><li class="chapter-item "><a href="../cargo/test.html"><strong aria-hidden="true">12.3.</strong> Tests</a></li><li class="chapter-item "><a href="../cargo/build_scripts.html"><strong aria-hidden="true">12.4.</strong> Build Scripts</a></li></ol></li><li class="chapter-item "><a href="../attribute.html"><strong aria-hidden="true">13.</strong> アトリビュート</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../attribute/unused.html"><strong aria-hidden="true">13.1.</strong> dead_code</a></li><li class="chapter-item "><a href="../attribute/crate.html"><strong aria-hidden="true">13.2.</strong> クレート</a></li><li class="chapter-item "><a href="../attribute/cfg.html"><strong aria-hidden="true">13.3.</strong> cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../attribute/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> 条件の追加</a></li></ol></li></ol></li><li class="chapter-item "><a href="../generics.html"><strong aria-hidden="true">14.</strong> ジェネリクス</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../generics/gen_fn.html"><strong aria-hidden="true">14.1.</strong> 関数</a></li><li class="chapter-item "><a href="../generics/impl.html"><strong aria-hidden="true">14.2.</strong> メソッド</a></li><li class="chapter-item "><a href="../generics/gen_trait.html"><strong aria-hidden="true">14.3.</strong> ジェネリックトレイト</a></li><li class="chapter-item "><a href="../generics/bounds.html"><strong aria-hidden="true">14.4.</strong> ジェネリック境界</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../generics/bounds/testcase_empty.html"><strong aria-hidden="true">14.4.1.</strong> テストケース: 空トレイト</a></li></ol></li><li class="chapter-item "><a href="../generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> 複数のジェネリック境界</a></li><li class="chapter-item "><a href="../generics/where.html"><strong aria-hidden="true">14.6.</strong> Where句</a></li><li class="chapter-item "><a href="../generics/new_types.html"><strong aria-hidden="true">14.7.</strong> ニュータイプイディオム</a></li><li class="chapter-item "><a href="../generics/assoc_items.html"><strong aria-hidden="true">14.8.</strong> 関連型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> 関連型が必要になる状況</a></li><li class="chapter-item "><a href="../generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> 関連型</a></li></ol></li><li class="chapter-item "><a href="../generics/phantom.html"><strong aria-hidden="true">14.9.</strong> 幽霊型パラメータ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> テストケース: 単位を扱う</a></li></ol></li></ol></li><li class="chapter-item "><a href="../scope.html"><strong aria-hidden="true">15.</strong> スコーピングの規則</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li class="chapter-item "><a href="../scope/move.html"><strong aria-hidden="true">15.2.</strong> 所有権とムーブ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../scope/move/mut.html"><strong aria-hidden="true">15.2.1.</strong> ミュータビリティ</a></li><li class="chapter-item "><a href="../scope/move/partial_move.html"><strong aria-hidden="true">15.2.2.</strong> 部分的ムーブ</a></li></ol></li><li class="chapter-item "><a href="../scope/borrow.html"><strong aria-hidden="true">15.3.</strong> 借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../scope/borrow/mut.html"><strong aria-hidden="true">15.3.1.</strong> ミュータビリティ</a></li><li class="chapter-item "><a href="../scope/borrow/alias.html"><strong aria-hidden="true">15.3.2.</strong> エイリアス</a></li><li class="chapter-item "><a href="../scope/borrow/ref.html"><strong aria-hidden="true">15.3.3.</strong> refパターン</a></li></ol></li><li class="chapter-item "><a href="../scope/lifetime.html"><strong aria-hidden="true">15.4.</strong> ライフタイム</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> 明示的アノテーション</a></li><li class="chapter-item "><a href="../scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> 関数</a></li><li class="chapter-item "><a href="../scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> メソッド</a></li><li class="chapter-item "><a href="../scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> 構造体</a></li><li class="chapter-item "><a href="../scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> トレイト</a></li><li class="chapter-item "><a href="../scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">15.4.6.</strong> ライフタイム境界</a></li><li class="chapter-item "><a href="../scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">15.4.7.</strong> 圧縮</a></li><li class="chapter-item "><a href="../scope/lifetime/static_lifetime.html"><strong aria-hidden="true">15.4.8.</strong> スタティックライフタイム</a></li><li class="chapter-item "><a href="../scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> 省略</a></li></ol></li></ol></li><li class="chapter-item "><a href="../trait.html"><strong aria-hidden="true">16.</strong> トレイト</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../trait/derive.html"><strong aria-hidden="true">16.1.</strong> 導出(Derive)</a></li><li class="chapter-item "><a href="../trait/dyn.html"><strong aria-hidden="true">16.2.</strong> dynを利用してトレイトを返す</a></li><li class="chapter-item "><a href="../trait/ops.html"><strong aria-hidden="true">16.3.</strong> 演算子のオーバーロード</a></li><li class="chapter-item "><a href="../trait/drop.html"><strong aria-hidden="true">16.4.</strong> メモリ解放</a></li><li class="chapter-item "><a href="../trait/iter.html"><strong aria-hidden="true">16.5.</strong> イテレータ</a></li><li class="chapter-item "><a href="../trait/impl_trait.html"><strong aria-hidden="true">16.6.</strong> impl Trait</a></li><li class="chapter-item "><a href="../trait/clone.html"><strong aria-hidden="true">16.7.</strong> クローン</a></li><li class="chapter-item "><a href="../trait/supertraits.html"><strong aria-hidden="true">16.8.</strong> スーパートレイト</a></li><li class="chapter-item "><a href="../trait/disambiguating.html"><strong aria-hidden="true">16.9.</strong> Disambiguating overlapping traits</a></li></ol></li><li class="chapter-item "><a href="../macros.html"><strong aria-hidden="true">17.</strong> macro_rules!</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../macros/syntax.html"><strong aria-hidden="true">17.1.</strong> 構文</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../macros/designators.html"><strong aria-hidden="true">17.1.1.</strong> 識別子</a></li><li class="chapter-item "><a href="../macros/overload.html"><strong aria-hidden="true">17.1.2.</strong> オーバーロード</a></li><li class="chapter-item "><a href="../macros/repeat.html"><strong aria-hidden="true">17.1.3.</strong> 繰り返し</a></li></ol></li><li class="chapter-item "><a href="../macros/dry.html"><strong aria-hidden="true">17.2.</strong> DRY (Don't Repeat Yourself)</a></li><li class="chapter-item "><a href="../macros/dsl.html"><strong aria-hidden="true">17.3.</strong> Domain Specific Languages (ドメイン特化言語、DSLs)</a></li><li class="chapter-item "><a href="../macros/variadics.html"><strong aria-hidden="true">17.4.</strong> 可変個引数</a></li></ol></li><li class="chapter-item "><a href="../error.html"><strong aria-hidden="true">18.</strong> エラーハンドリング</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li class="chapter-item "><a href="../error/abort_unwind.html"><strong aria-hidden="true">18.2.</strong> abort & unwind</a></li><li class="chapter-item "><a href="../error/option_unwrap.html"><strong aria-hidden="true">18.3.</strong> Option と unwrap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../error/option_unwrap/question_mark.html"><strong aria-hidden="true">18.3.1.</strong> ?によるOptionのアンパック</a></li><li class="chapter-item "><a href="../error/option_unwrap/map.html"><strong aria-hidden="true">18.3.2.</strong> Combinators: map</a></li><li class="chapter-item "><a href="../error/option_unwrap/and_then.html"><strong aria-hidden="true">18.3.3.</strong> Combinators: and_then</a></li><li class="chapter-item "><a href="../error/option_unwrap/defaults.html"><strong aria-hidden="true">18.3.4.</strong> Defaults: or, or_else, get_or_insert, 'get_or_insert_with`</a></li></ol></li><li class="chapter-item "><a href="../error/result.html"><strong aria-hidden="true">18.4.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../error/result/result_map.html"><strong aria-hidden="true">18.4.1.</strong> Resultのmap</a></li><li class="chapter-item "><a href="../error/result/result_alias.html"><strong aria-hidden="true">18.4.2.</strong> Resultに対するエイリアス</a></li><li class="chapter-item "><a href="../error/result/early_returns.html"><strong aria-hidden="true">18.4.3.</strong> 早期リターン</a></li><li class="chapter-item "><a href="../error/result/enter_question_mark.html"><strong aria-hidden="true">18.4.4.</strong> ?の導入</a></li></ol></li><li class="chapter-item "><a href="../error/multiple_error_types.html"><strong aria-hidden="true">18.5.</strong> 複数のエラー型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.5.1.</strong> OptionからResultを取り出す</a></li><li class="chapter-item "><a href="../error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.5.2.</strong> エラー型を定義する</a></li><li class="chapter-item "><a href="../error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.5.3.</strong> エラーをBoxする</a></li><li class="chapter-item "><a href="../error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.5.4.</strong> ?の他の活用法</a></li><li class="chapter-item "><a href="../error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">18.5.5.</strong> エラーをラップする</a></li></ol></li><li class="chapter-item "><a href="../error/iter_result.html"><strong aria-hidden="true">18.6.</strong> Resultをイテレートする</a></li></ol></li><li class="chapter-item "><a href="../std.html"><strong aria-hidden="true">19.</strong> 標準ライブラリの型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std/box.html"><strong aria-hidden="true">19.1.</strong> Box, スタックとヒープ</a></li><li class="chapter-item "><a href="../std/vec.html"><strong aria-hidden="true">19.2.</strong> ベクタ型</a></li><li class="chapter-item "><a href="../std/str.html"><strong aria-hidden="true">19.3.</strong> 文字列</a></li><li class="chapter-item "><a href="../std/option.html"><strong aria-hidden="true">19.4.</strong> Option</a></li><li class="chapter-item "><a href="../std/result.html"><strong aria-hidden="true">19.5.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ?</a></li></ol></li><li class="chapter-item "><a href="../std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li class="chapter-item "><a href="../std/hash.html"><strong aria-hidden="true">19.7.</strong> ハッシュマップ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> key型の変種</a></li><li class="chapter-item "><a href="../std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> ハッシュ集合</a></li></ol></li><li class="chapter-item "><a href="../std/rc.html"><strong aria-hidden="true">19.8.</strong> Rc</a></li><li class="chapter-item "><a href="../std/arc.html"><strong aria-hidden="true">19.9.</strong> Arc</a></li></ol></li><li class="chapter-item "><a href="../std_misc.html"><strong aria-hidden="true">20.</strong> 標準ライブラリのその他</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std_misc/threads.html"><strong aria-hidden="true">20.1.</strong> スレッド</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">20.1.1.</strong> Testcase: map-reduce</a></li></ol></li><li class="chapter-item "><a href="../std_misc/channels.html"><strong aria-hidden="true">20.2.</strong> チャネル</a></li><li class="chapter-item "><a href="../std_misc/path.html"><strong aria-hidden="true">20.3.</strong> Path</a></li><li class="chapter-item "><a href="../std_misc/file.html"><strong aria-hidden="true">20.4.</strong> ファイル I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std_misc/file/open.html"><strong aria-hidden="true">20.4.1.</strong> open</a></li><li class="chapter-item "><a href="../std_misc/file/create.html"><strong aria-hidden="true">20.4.2.</strong> create</a></li><li class="chapter-item "><a href="../std_misc/file/read_lines.html"><strong aria-hidden="true">20.4.3.</strong> read lines</a></li></ol></li><li class="chapter-item "><a href="../std_misc/process.html"><strong aria-hidden="true">20.5.</strong> 子プロセス</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std_misc/process/pipe.html"><strong aria-hidden="true">20.5.1.</strong> パイプ</a></li><li class="chapter-item "><a href="../std_misc/process/wait.html"><strong aria-hidden="true">20.5.2.</strong> dropの延期</a></li></ol></li><li class="chapter-item "><a href="../std_misc/fs.html"><strong aria-hidden="true">20.6.</strong> ファイルシステムとのやり取り</a></li><li class="chapter-item "><a href="../std_misc/arg.html"><strong aria-hidden="true">20.7.</strong> 引数処理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../std_misc/arg/matching.html"><strong aria-hidden="true">20.7.1.</strong> 引数のパース</a></li></ol></li><li class="chapter-item "><a href="../std_misc/ffi.html"><strong aria-hidden="true">20.8.</strong> 他言語関数インターフェイス</a></li></ol></li><li class="chapter-item "><a href="../testing.html"><strong aria-hidden="true">21.</strong> テスト</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../testing/unit_testing.html"><strong aria-hidden="true">21.1.</strong> ユニットテスト</a></li><li class="chapter-item "><a href="../testing/doc_testing.html"><strong aria-hidden="true">21.2.</strong> ドキュメンテーションテスト</a></li><li class="chapter-item "><a href="../testing/integration_testing.html"><strong aria-hidden="true">21.3.</strong> インテグレーションテスト</a></li><li class="chapter-item "><a href="../testing/dev_dependencies.html"><strong aria-hidden="true">21.4.</strong> 開発中の依存関係</a></li></ol></li><li class="chapter-item expanded "><a href="../unsafe.html"><strong aria-hidden="true">22.</strong> 安全でない操作</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unsafe/asm.html" class="active"><strong aria-hidden="true">22.1.</strong> インラインアセンブリ</a></li></ol></li><li class="chapter-item "><a href="../compatibility.html"><strong aria-hidden="true">23.</strong> 互換性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../compatibility/raw_identifiers.html"><strong aria-hidden="true">23.1.</strong> 生識別子</a></li></ol></li><li class="chapter-item "><a href="../meta.html"><strong aria-hidden="true">24.</strong> 周辺情報</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../meta/doc.html"><strong aria-hidden="true">24.1.</strong> ドキュメンテーション</a></li><li class="chapter-item "><a href="../meta/playground.html"><strong aria-hidden="true">24.2.</strong> プレイグラウンド</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Example 日本語版</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-ja/rust-by-example-ja" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Inline assembly
-->
<h1 id="インラインアセンブリ"><a class="header" href="#インラインアセンブリ">インラインアセンブリ</a></h1>
<!--
Rust provides support for inline assembly via the `asm!` macro.
It can be used to embed handwritten assembly in the assembly output generated by the compiler.
Generally this should not be necessary, but might be where the required performance or timing
cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.
-->
<p>Rustは<code>asm!</code>マクロによってインラインアセンブリをサポートしています。
コンパイラが生成するアセンブリに、手書きのアセンブリを埋め込むことができます。
一般的には必要ありませんが、要求されるパフォーマンスやタイミングを達成するために必要な場合があります。
カーネルコードのような、低レベルなハードウェアの基本要素にアクセスする場合にも、この機能が必要でしょう。</p>
<!--
> **Note**: the examples here are given in x86/x86-64 assembly, but other architectures are also supported.
-->
<blockquote>
<p><strong>注意</strong>: 以下の例はx86/x86-64アセンブリで書かれていますが、他のアーキテクチャもサポートされています。</p>
</blockquote>
<!--
Inline assembly is currently supported on the following architectures:
- x86 and x86-64
- ARM
- AArch64
- RISC-V
-->
<p>インラインアセンブリは現在以下のアーキテクチャでサポートされています。</p>
<ul>
<li>x86とx86-64</li>
<li>ARM</li>
<li>AArch64</li>
<li>RISC-V</li>
</ul>
<!--
## Basic usage
-->
<h2 id="基本的な使い方"><a class="header" href="#基本的な使い方">基本的な使い方</a></h2>
<!--
Let us start with the simplest possible example:
-->
<p>最も単純な例から始めましょう。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

unsafe {
    asm!(&quot;nop&quot;);
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
This will insert a NOP (no operation) instruction into the assembly generated by the compiler.
Note that all `asm!` invocations have to be inside an `unsafe` block, as they could insert
arbitrary instructions and break various invariants. The instructions to be inserted are listed
in the first argument of the `asm!` macro as a string literal.
-->
<p>これは、コンパイラが生成したアセンブリに、NOP (no operation) 命令を挿入します。
すべての<code>asm!</code>呼び出しは、<code>unsafe</code>ブロックの中になければいけません。
インラインアセンブリは任意の命令を挿入でき、不変条件を壊してしまうからです。
挿入される命令は、文字列リテラルとして<code>asm!</code>マクロの第一引数に列挙されます。</p>
<!--
## Inputs and outputs
-->
<h2 id="入力と出力"><a class="header" href="#入力と出力">入力と出力</a></h2>
<!--
Now inserting an instruction that does nothing is rather boring. Let us do something that
actually acts on data:
-->
<p>何もしない命令を挿入しても面白くありません。
実際にデータを操作してみましょう。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let x: u64;
unsafe {
    asm!(&quot;mov {}, 5&quot;, out(reg) x);
}
assert_eq!(x, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
This will write the value `5` into the `u64` variable `x`.
You can see that the string literal we use to specify instructions is actually a template string.
It is governed by the same rules as Rust [format strings][format-syntax].
The arguments that are inserted into the template however look a bit different than you may
be familiar with. First we need to specify if the variable is an input or an output of the
inline assembly. In this case it is an output. We declared this by writing `out`.
We also need to specify in what kind of register the assembly expects the variable.
In this case we put it in an arbitrary general purpose register by specifying `reg`.
The compiler will choose an appropriate register to insert into
the template and will read the variable from there after the inline assembly finishes executing.
-->
<p>これは<code>u64</code>型の変数<code>x</code>に<code>5</code>の値を書き込んでいます。
命令を指定するために利用している文字列リテラルが、実はテンプレート文字列になっています。
これはRustの<a href="https://doc.rust-lang.org/std/fmt/#syntax">フォーマット文字列</a>と同じルールに従います。
ですが、テンプレートに挿入される引数は、みなさんがよく知っているものとは少し違っています。
まず、変数がインラインアセンブリの入力なのか出力なのかを指定する必要があります。
上記の例では出力となっています。
<code>out</code>と書くことで出力であると宣言しています。
また、アセンブリが変数をどの種類のレジスタに格納するかについても指定する必要があります。
上の例では、<code>reg</code>を指定して任意の汎用レジスタに格納しています。
コンパイラはテンプレートに挿入する適切なレジスタを選び、インラインアセンブリの実行終了後、そのレジスタから変数を読みこみます。</p>
<!--
Let us see another example that also uses an input:
-->
<p>入力を利用する別の例を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let i: u64 = 3;
let o: u64;
unsafe {
    asm!(
        &quot;mov {0}, {1}&quot;,
        &quot;add {0}, 5&quot;,
        out(reg) o,
        in(reg) i,
    );
}
assert_eq!(o, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
This will add `5` to the input in variable `i` and write the result to variable `o`.
The particular way this assembly does this is first copying the value from `i` to the output,
and then adding `5` to it.
-->
<p>この例では、変数<code>i</code>の入力に<code>5</code>を加え、その結果を変数<code>o</code>に書き込んでいます。
このアセンブリ特有のやり方として、はじめに<code>i</code>の値を出力にコピーし、それから<code>5</code>を加えています。</p>
<!--
The example shows a few things:
-->
<p>この例はいくつかのことを示します。</p>
<!--
First, we can see that `asm!` allows multiple template string arguments; each
one is treated as a separate line of assembly code, as if they were all joined
together with newlines between them. This makes it easy to format assembly
code.
-->
<p>まず、<code>asm!</code>では複数のテンプレート文字列を引数として利用できます。
それぞれの文字列は、改行を挟んで結合されたのと同じように、独立したアセンブリコードとして扱われます。
このおかげで、アセンブリコードを容易にフォーマットできます。</p>
<!--
Second, we can see that inputs are declared by writing `in` instead of `out`.
-->
<p>つぎに、入力は<code>out</code>ではなく<code>in</code>と書くことで宣言されています。</p>
<!--
Third, we can see that we can specify an argument number, or name as in any format string.
For inline assembly templates this is particularly useful as arguments are often used more than once.
For more complex inline assembly using this facility is generally recommended, as it improves
readability, and allows reordering instructions without changing the argument order.
-->
<p>そして、他のフォーマット文字列と同じように引数を番号や名前で指定できます。
インラインアセンブリのテンプレートでは、引数が2回以上利用されることが多いため、これは特に便利です。
より複雑なインラインアセンブリを書く場合、この機能を使うのが推奨されます。
可読性が向上し、引数の順序を変えることなく命令を並べ替えることができるからです。</p>
<!--
We can further refine the above example to avoid the `mov` instruction:
-->
<p>上記の例をさらに改善して、<code>mov</code>命令をやめることもできます。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let mut x: u64 = 3;
unsafe {
    asm!(&quot;add {0}, 5&quot;, inout(reg) x);
}
assert_eq!(x, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
We can see that `inout` is used to specify an argument that is both input and output.
This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.
-->
<p><code>inout</code>で入力でもあり出力でもある引数を指定しています。
こうすることで、入力と出力を個別に指定する場合と違って、入出力が同じレジスタに割り当てられることが保証されます。</p>
<!--
It is also possible to specify different variables for the input and output parts of an `inout` operand:
-->
<p><code>inout</code>のオペランドとして、入力と出力それぞれに異なる変数を指定することも可能です。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let x: u64 = 3;
let y: u64;
unsafe {
    asm!(&quot;add {0}, 5&quot;, inout(reg) x =&gt; y);
}
assert_eq!(y, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
## Late output operands
-->
<h2 id="遅延出力オペランド"><a class="header" href="#遅延出力オペランド">遅延出力オペランド</a></h2>
<!--
The Rust compiler is conservative with its allocation of operands. It is assumed that an `out`
can be written at any time, and can therefore not share its location with any other argument.
However, to guarantee optimal performance it is important to use as few registers as possible,
so they won't have to be saved and reloaded around the inline assembly block.
To achieve this Rust provides a `lateout` specifier. This can be used on any output that is
written only after all inputs have been consumed.
There is also a `inlateout` variant of this specifier.
-->
<p>Rustコンパイラはオペランドの割り当てに保守的です。
<code>out</code>はいつでも書き込めるので、他の引数とは場所を共有できません。
しかし、最適なパフォーマンスを保証するためには、できるだけ少ないレジスタを使うことが重要です。
そうすることで、インラインアセンブリブロックの前後でレジスタを保存したり再読み込みしたりする必要がありません。
これを達成するために、Rustは<code>lateout</code>指定子を提供します。
全ての入力が消費された後でのみ書き込まれる出力に利用できます。
この指定子には<code>inlateout</code>という変化形もあります。</p>
<!--
Here is an example where `inlateout` *cannot* be used in `release` mode or other optimized cases:
-->
<p>以下は、<code>release</code>モードやその他の最適化された場合に、<code>inlateout</code>を利用 <em>できない</em> 例です。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
let c: u64 = 4;
unsafe {
    asm!(
        &quot;add {0}, {1}&quot;,
        &quot;add {0}, {2}&quot;,
        inout(reg) a,
        in(reg) b,
        in(reg) c,
    );
}
assert_eq!(a, 12);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
The above could work well in unoptimized cases (`Debug` mode), but if you want optimized performance (`release` mode or other optimized cases), it could not work.
-->
<p>上記は<code>Debug</code>モードなど最適化されていない場合にはうまく動作します。
しかし、<code>release</code>モードなど最適化されたパフォーマンスが必要な場合、動作しない可能性があります。</p>
<!--
That is because in optimized cases, the compiler is free to allocate the same register for inputs `b` and `c` since it knows they have the same value. However it must allocate a separate register for `a` since it uses `inout` and not `inlateout`. If `inlateout` was used, then `a` and `c` could be allocated to the same register, in which case the first instruction to overwrite the value of `c` and cause the assembly code to produce the wrong result.
-->
<p>というのも、最適化されている場合、コンパイラは<code>b</code>と<code>c</code>が同じ値だと知っているので、
<code>b</code>と<code>c</code>の入力に同じレジスタを割り当てる場合があります。
しかし、<code>a</code>については<code>inlateout</code>ではなく<code>inout</code>を使っているので、独立したレジスタを割り当てる必要があります。
もし<code>inlateout</code>が使われていたら、<code>a</code>と<code>c</code>に同じレジスタが割り当てられたかもしれません。
そうすると、最初の命令によって<code>c</code>の値が上書きされ、アセンブリコードが間違った結果を引き起こします。</p>
<!--
However the following example can use `inlateout` since the output is only modified after all input registers have been read:
-->
<p>しかし、次の例では、全ての入力レジスタが読み込まれた後でのみ出力が変更されるので、<code>inlateout</code>を利用できます。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(&quot;add {0}, {1}&quot;, inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
As you can see, this assembly fragment will still work correctly if `a` and `b` are assigned to the same register.
-->
<p>このアセンブリコードは、<code>a</code>と<code>b</code>が同じレジスタに割り当てられても、正しく動作します。</p>
<!--
## Explicit register operands
-->
<h2 id="明示的なレジスタオペランド"><a class="header" href="#明示的なレジスタオペランド">明示的なレジスタオペランド</a></h2>
<!--
Some instructions require that the operands be in a specific register.
Therefore, Rust inline assembly provides some more specific constraint specifiers.
While `reg` is generally available on any architecture, explicit registers are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi` among others can be addressed by their name.
-->
<p>いくつかの命令では、オペランドが特定のレジスタにある必要があります。
したがって、Rustのインラインアセンブリでは、より具体的な制約指定子を提供しています。
<code>reg</code>は一般的にどのアーキテクチャでも利用可能ですが、明示的レジスタはアーキテクチャに強く依存しています。
たとえば、x86の汎用レジスタである<code>eax</code>、<code>ebx</code>、<code>ecx</code>、<code>edx</code>、<code>ebp</code>、<code>esi</code>、<code>edi</code>などは、その名前で指定できます。</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let cmd = 0xd1;
unsafe {
    asm!(&quot;out 0x64, eax&quot;, in(&quot;eax&quot;) cmd);
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
In this example we call the `out` instruction to output the content of the `cmd` variable to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand we had to use the `eax` constraint specifier.
-->
<p>この例では、<code>out</code>命令を呼び出して、<code>cmd</code>変数の中身を<code>0x64</code>ポートに出力しています。
<code>out</code>命令は<code>eax</code>とそのサブレジスタのみをオペランドとして受け取るため、
<code>eax</code>の制約指定子を使わなければなりません。</p>
<!--
> **Note**: unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.
-->
<blockquote>
<p><strong>注意</strong>: 他のオペランドタイプと異なり、明示的なレジスタオペランドはテンプレート文字列中で利用できません。
<code>{}</code>を使えないので、レジスタの名前を直接書く必要があります。
また、オペランドのリストの中で他のオペランドタイプの一番最後に置かれなくてはなりません。</p>
</blockquote>
<!--
Consider this example which uses the x86 `mul` instruction:
-->
<p>x86の<code>mul</code>命令を使った次の例を考えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

fn mul(a: u64, b: u64) -&gt; u128 {
    let lo: u64;
    let hi: u64;

    unsafe {
        asm!(
            // The x86 mul instruction takes rax as an implicit input and writes
            // the 128-bit result of the multiplication to rax:rdx.
            // x86のmul命令はraxを暗黙的な入力に取り、
            // 128ビットの乗算結果をrax:rdxに書き込む。
            &quot;mul {}&quot;,
            in(reg) a,
            inlateout(&quot;rax&quot;) b =&gt; lo,
            lateout(&quot;rdx&quot;) hi
        );
    }

    ((hi as u128) &lt;&lt; 64) + lo as u128
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
This uses the `mul` instruction to multiply two 64-bit inputs with a 128-bit result.
The only explicit operand is a register, that we fill from the variable `a`.
The second operand is implicit, and must be the `rax` register, which we fill from the variable `b`.
The lower 64 bits of the result are stored in `rax` from which we fill the variable `lo`.
The higher 64 bits are stored in `rdx` from which we fill the variable `hi`.
-->
<p><code>mul</code>命令を使って2つの64ビットの入力を128ビットの結果に出力しています。
唯一の明示的なオペランドはレジスタで、変数<code>a</code>から入力します。
2つ目のオペランドは暗黙的であり、<code>rax</code>レジスタである必要があります。変数<code>b</code>から<code>rax</code>レジスタに入力します。
計算結果の下位64ビットは<code>rax</code>レジスタに保存され、そこから変数<code>lo</code>に出力されます。
上位64ビットは<code>rdx</code>レジスタに保存され、そこから変数<code>hi</code>に出力されます。</p>
<!--
## Clobbered registers
-->
<h2 id="クロバーレジスタ"><a class="header" href="#クロバーレジスタ">クロバーレジスタ</a></h2>
<!--
In many cases inline assembly will modify state that is not needed as an output.
Usually this is either because we have to use a scratch register in the assembly or because instructions modify state that we don't need to further examine.
This state is generally referred to as being "clobbered".
We need to tell the compiler about this since it may need to save and restore this state around the inline assembly block.
-->
<p>多くの場合、インラインアセンブリは出力として必要のない状態を変更することがあります。
これは普通、アセンブリでスクラッチレジスタを利用する必要があったり、
私たちがこれ以上必要としていない状態を命令が変更したりするためです。
この状態を一般的に&quot;クロバー&quot;（訳注：上書き）と呼びます。
私たちはコンパイラにこのことを伝える必要があります。
なぜならコンパイラは、インラインアセンブリブロックの前後で、
この状態を保存して復元しなくてはならない可能性があるからです。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::arch::asm;

<span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)]
</span>fn main() {
    // three entries of four bytes each
    // 4バイトのエントリー3つ
    let mut name_buf = [0_u8; 12];
    // String is stored as ascii in ebx, edx, ecx in order
    // Because ebx is reserved, the asm needs to preserve the value of it.
    // So we push and pop it around the main asm.
    // (in 64 bit mode for 64 bit processors, 32 bit processors would use ebx)
    // 文字列はasciiとしてebx, edx, ecxの順に保存されている。
    // ebxは予約されているので、アセンブリはebxの値を維持する必要がある。
    // 従ってメインのアセンブリの前後でプッシュおよびポップを行う。
    // (以下は64ビットプロセッサの64ビットモードの場合。32ビットプロセッサはebxを利用する。)

    unsafe {
        asm!(
            &quot;push rbx&quot;,
            &quot;cpuid&quot;,
            &quot;mov [rdi], ebx&quot;,
            &quot;mov [rdi + 4], edx&quot;,
            &quot;mov [rdi + 8], ecx&quot;,
            &quot;pop rbx&quot;,
            // We use a pointer to an array for storing the values to simplify
            // the Rust code at the cost of a couple more asm instructions
            // This is more explicit with how the asm works however, as opposed
            // to explicit register outputs such as `out(&quot;ecx&quot;) val`
            // The *pointer itself* is only an input even though it's written behind
            // いくつかのアセンブリ命令を追加してRustのコードを単純化するために
            // 値を格納する配列へのポインタを利用する。
            // しかし、`out(&quot;ecx&quot;) val`のような明示的なレジスタの出力とは違い、
            // アセンブリの動作をより明示的にする。
            // *ポインタそのもの* は後ろに書かれていても入力にすぎない。
            in(&quot;rdi&quot;) name_buf.as_mut_ptr(),
            // select cpuid 0, also specify eax as clobbered
            // cpuid 0を選択し、eaxをクロバーに指定する
            inout(&quot;eax&quot;) 0 =&gt; _,
            // cpuid clobbers these registers too
            // cpuidは以下のレジスタもクロバーする
            out(&quot;ecx&quot;) _,
            out(&quot;edx&quot;) _,
        );
    }

    let name = core::str::from_utf8(&amp;name_buf).unwrap();
    println!(&quot;CPU Manufacturer ID: {}&quot;, name);
}

<span class="boring">#[cfg(not(target_arch = &quot;x86_64&quot;))]
</span><span class="boring">fn main() {}</span></code></pre></pre>
<!--
In the example above we use the `cpuid` instruction to read the CPU manufacturer ID.
This instruction writes to `eax` with the maximum supported `cpuid` argument and `ebx`, `edx`, and `ecx` with the CPU manufacturer ID as ASCII bytes in that order.
-->
<p>上の例では、<code>cpuid</code>命令を使い、CPUベンタIDを読み込んでいます。
この命令は<code>eax</code>にサポートされている最大の<code>cpuid</code>引数を書き込み、
<code>ebx</code>、<code>edx</code>、<code>ecx</code>の順にCPUベンダIDをASCIIコードとして書き込みます。</p>
<!--
Even though `eax` is never read we still need to tell the compiler that the register has been modified so that the compiler can save any values that were in these registers before the asm. This is done by declaring it as an output but with `_` instead of a variable name, which indicates that the output value is to be discarded.
-->
<p><code>eax</code>は読み込まれることはありません。
しかし、コンパイラがアセンブリ以前にこれらのレジスタにあった値を保存できるように、
レジスタが変更されたことをコンパイラに伝える必要があります。
そのために、変数名の代わりに<code>_</code>を用いて出力を宣言し、出力の値が破棄されるということを示しています。</p>
<!--
This code also works around the limitation that `ebx` is a reserved register by LLVM. That means that LLVM assumes that it has full control over the register and it must be restored to its original state before exiting the asm block, so it cannot be used as an input or output **except** if the compiler uses it to fulfill a general register class (e.g. `in(reg)`). This makes `reg` operands dangerous when using reserved registers as we could unknowingly corrupt our input or output because they share the same register.
-->
<p>このコードは<code>ebx</code>がLLVMによって予約されたレジスタであるという制約を回避しています。
LLVMは、自身がレジスタを完全にコントロールし、
アセンブリブロックを抜ける前に元の状態を復元しなくてはならないと考えています。
そのため、コンパイラが<code>in(reg)</code>のような汎用レジスタクラスを満たすために使用する場合 <strong>を除いて</strong> <code>ebx</code>を入力や出力として利用できません。
つまり、予約されたレジスタを利用する場合に、<code>reg</code>オペランドは危険なのです。入力と出力が同じレジスタを共有しているので、知らないうちに入力や出力を破壊してしまうかもしれません。</p>
<!--
To work around this we use `rdi` to store the pointer to the output array, save `ebx` via `push`, read from `ebx` inside the asm block into the array and then restore `ebx` to its original state via `pop`. The `push` and `pop` use the full 64-bit `rbx` version of the register to ensure that the entire register is saved. On 32 bit targets the code would instead use `ebx` in the `push`/`pop`.
-->
<p>これを回避するために、<code>rdi</code>を用いて出力の配列へのポインタを保管し、<code>push</code>で<code>ebx</code>を保存し、アセンブリブロック内で<code>ebx</code>から読み込んで配列に書き込み、<code>pop</code>で<code>ebx</code>を元の状態に戻しています。
<code>push</code>と<code>pop</code>は完全な64ビットの<code>rbx</code>レジスタを使って、レジスタ全体を確実に保存しています。
32ビットの場合、<code>push</code>と<code>pop</code>において<code>ebx</code>がかわりに利用されるでしょう。</p>
<!--
This can also be used with a general register class to obtain a scratch register for use inside the asm code:
-->
<p>アセンブリコード内部で利用するスクラッチレジスタを獲得するために、
汎用レジスタクラスとともに使用することもできます。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

// Multiply x by 6 using shifts and adds
// シフト演算と加算を利用してxに6をかける
let mut x: u64 = 4;
unsafe {
    asm!(
        &quot;mov {tmp}, {x}&quot;,
        &quot;shl {tmp}, 1&quot;,
        &quot;shl {x}, 2&quot;,
        &quot;add {x}, {tmp}&quot;,
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
## Symbol operands and ABI clobbers
-->
<h2 id="シンボルオペランドとabiクロバー"><a class="header" href="#シンボルオペランドとabiクロバー">シンボル・オペランドとABIクロバー</a></h2>
<!--
By default, `asm!` assumes that any register not specified as an output will have its contents preserved by the assembly code. The [`clobber_abi`] argument to `asm!` tells the compiler to automatically insert the necessary clobber operands according to the given calling convention ABI: any register which is not fully preserved in that ABI will be treated as clobbered.  Multiple `clobber_abi` arguments may be provided and all clobbers from all specified ABIs will be inserted.
-->
<p>デフォルトでは、<code>asm!</code>は、出力として指定されていないレジスタはアセンブリコードによって中身が維持される、と考えます。
<code>asm!</code>に渡される<a href="../../reference/inline-assembly.html#abi-clobbers"><code>clobber_abi</code></a>引数は、与えられた呼び出し規約のABIに従って、
必要なクロバーオペランドを自動的に挿入するようコンパイラに伝えます。
そのABIで完全に保存されていないレジスタは、クロバーとして扱われます。
複数の <code>clobber_abi</code> 引数を指定すると、指定されたすべてのABIのクロバーが挿入されます。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

extern &quot;C&quot; fn foo(arg: i32) -&gt; i32 {
    println!(&quot;arg = {}&quot;, arg);
    arg * 2
}

fn call_foo(arg: i32) -&gt; i32 {
    unsafe {
        let result;
        asm!(
            &quot;call {}&quot;,
            // Function pointer to call
            // 呼び出す関数ポインタ
            in(reg) foo,
            // 1st argument in rdi
            // 最初の引数はrdiにある
            in(&quot;rdi&quot;) arg,
            // Return value in rax
            // 戻り値はraxにある
            out(&quot;rax&quot;) result,
            // Mark all registers which are not preserved by the &quot;C&quot; calling
            // convention as clobbered.
            // &quot;C&quot;の呼び出し規約で保存されていないすべてのレジスタをクロバーに指定
            clobber_abi(&quot;C&quot;),
        );
        result
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
## Register template modifiers
-->
<h2 id="レジスタテンプレート修飾子"><a class="header" href="#レジスタテンプレート修飾子">レジスタテンプレート修飾子</a></h2>
<!--
In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a "view" over a subset of the register (e.g. the low 32 bits of a 64-bit register).
-->
<p>テンプレート文字列に挿入されるレジスタの名前のフォーマット方法について、細かい制御が必要な場合があります。
アーキテクチャのアセンブリ言語が、同じレジスタに別名を持っている場合です。
典型的な例としては、レジスタの部分集合に対する&quot;ビュー&quot;があります（例：64ビットレジスタの下位32ビット）。</p>
<!--
By default the compiler will always choose the name that refers to the full register size (e.g. `rax` on x86-64, `eax` on x86, etc).
-->
<p>デフォルトでは、コンパイラは常に完全なレジスタサイズの名前を選択します（例：x86-64では<code>rax</code>、x86では<code>eax</code>、など）。</p>
<!--
This default can be overridden by using modifiers on the template string operands, just like you would with format strings:
-->
<p>この挙動は、フォーマット文字列と同じように、テンプレート文字列のオペランドに修飾子を利用することで上書きできます。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let mut x: u16 = 0xab;

unsafe {
    asm!(&quot;mov {0:h}, {0:l}&quot;, inout(reg_abcd) x);
}

assert_eq!(x, 0xabab);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
In this example, we use the `reg_abcd` register class to restrict the register allocator to the 4 legacy x86 registers (`ax`, `bx`, `cx`, `dx`) of which the first two bytes can be addressed independently.
-->
<p>この例では、<code>reg_abcd</code>レジスタクラスを用いて、レジスタアロケータを4つのレガシーなx86レジスタ (<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>) に制限しています。このうち最初の2バイトは独立して指定できます。</p>
<!--
Let us assume that the register allocator has chosen to allocate `x` in the `ax` register.
The `h` modifier will emit the register name for the high byte of that register and the `l` modifier will emit the register name for the low byte. The asm code will therefore be expanded as `mov ah, al` which copies the low byte of the value into the high byte.
-->
<p>レジスタアロケータが<code>x</code>を<code>ax</code>レジスタに割り当てることにしたと仮定しましょう。
<code>h</code>修飾子はそのレジスタの上位バイトのレジスタ名を出力し、<code>l</code>修飾子は下位バイトのレジスタ名を出力します。
したがって、このアセンブリコードは<code>mov ah, al</code>に展開され、値の下位バイトを上位バイトにコピーします。</p>
<!--
If you use a smaller data type (e.g. `u16`) with an operand and forget to use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.
-->
<p>より小さなデータ型（例：<code>u16</code>）をオペランドに利用し、テンプレート修飾子を使い忘れた場合、
コンパイラは警告を出力し、正しい修飾子を提案してくれます。</p>
<!--
## Memory address operands
-->
<h2 id="メモリアドレスオペランド"><a class="header" href="#メモリアドレスオペランド">メモリアドレスオペランド</a></h2>
<!--
Sometimes assembly instructions require operands passed via memory addresses/memory locations.
You have to manually use the memory address syntax specified by the target architecture.
For example, on x86/x86_64 using Intel assembly syntax, you should wrap inputs/outputs in `[]` to indicate they are memory operands:
-->
<p>アセンブリ命令はオペランドがメモリアドレスやメモリロケーション経由で渡される必要なこともあります。
そのときは手動で、ターゲットのアーキテクチャによって指定されたメモリアドレスのシンタックスを利用しなくてはなりません。
例えば、Intelのアセンブリシンタックスを使うx86/x86_64の場合、入出力を<code>[]</code>で囲んで、メモリオペランドであることを示さなくてはなりません。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

fn load_fpu_control_word(control: u16) {
    unsafe {
        asm!(&quot;fldcw [{}]&quot;, in(reg) &amp;control, options(nostack));
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
## Labels
-->
<h2 id="ラベル"><a class="header" href="#ラベル">ラベル</a></h2>
<!--
Any reuse of a named label, local or otherwise, can result in an assembler or linker error or may cause other strange behavior. Reuse of a named label can happen in a variety of ways including:
-->
<p>名前つきラベルの再利用は、ローカルかそうでないかに関わらず、アセンブラやリンカのエラーを引き起こしたり、変な挙動の原因となります。
名前つきラベルの再利用は以下のようなケースがあります。</p>
<!--
-   explicitly: using a label more than once in one `asm!` block, or multiple times across blocks.
-   implicitly via inlining: the compiler is allowed to instantiate multiple copies of an `asm!` block, for example when the function containing it is inlined in multiple places.
-   implicitly via LTO: LTO can cause code from *other crates* to be placed in the same codegen unit, and so could bring in arbitrary labels.
-->
<ul>
<li>明示的再利用: 同じラベルを1つの<code>asm!</code>ブロック中で、または複数のブロック中で2回以上利用する場合です。</li>
<li>インライン化による暗黙の再利用: コンパイラは<code>asm!</code>ブロックの複数のコピーをインスタンス化する場合があります。例えば、<code>asm!</code>ブロックを含む関数が複数箇所でインライン化される場合です。</li>
<li>LTO(訳注: Link Time Optimizationの略)による暗黙の再利用: LTOは <em>他のクレート</em> のコードを同じコード生成単位に配置するため、同じ名前のラベルを持ち込む場合があります。</li>
</ul>
<!--
As a consequence, you should only use GNU assembler **numeric** [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.
-->
<p>そのため、インラインアセンブリコードの中では、GNUアセンブラの <strong>数値型</strong> <a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels">ローカルラベル</a>のみ使用してください。
アセンブリコード内でシンボルを定義すると、シンボル定義の重複により、アセンブラやリンカのエラーが発生する可能性があります。</p>
<!--
Moreover, on x86 when using the default Intel syntax, due to [an LLVM bug], you shouldn't use labels exclusively made of `0` and `1` digits, e.g. `0`, `11` or `101010`, as they may end up being interpreted as binary values. Using `options(att_syntax)` will avoid any ambiguity, but that affects the syntax of the _entire_ `asm!` block. (See [Options](#options), below, for more on `options`.)
-->
<p>さらに、x86でデフォルトのIntel構文を使用する場合、<a href="https://bugs.llvm.org/show_bug.cgi?id=36144">LLVMのバグ</a>によって、
<code>0</code>、<code>11</code>、<code>101010</code>といった<code>0</code>と<code>1</code>だけで構成されたラベルは、
バイナリ値として解釈されてしまうため、使用してはいけません。
<code>options(att_syntax)</code>を使うと曖昧さを避けられますが、<code>asm!</code>ブロック <em>全体</em> の構文に影響します。
(<code>options</code>については、後述の<a href="#options">オプション</a>を参照してください。)</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let mut a = 0;
unsafe {
    asm!(
        &quot;mov {0}, 10&quot;,
        &quot;2:&quot;,
        &quot;sub {0}, 1&quot;,
        &quot;cmp {0}, 3&quot;,
        &quot;jle 2f&quot;,
        &quot;jmp 2b&quot;,
        &quot;2:&quot;,
        &quot;add {0}, 2&quot;,
        out(reg) a
    );
}
assert_eq!(a, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
This will decrement the `{0}` register value from 10 to 3, then add 2 and store it in `a`.
-->
<p>このコードは、<code>{0}</code>のレジスタの値を10から3にデクリメントし、2を加え、<code>a</code>にその値を保存します。</p>
<!--
This example shows a few things:
-->
<p>この例は、以下のことを示しています。</p>
<!--
- First, that the same number can be used as a label multiple times in the same inline block.
- Second, that when a numeric label is used as a reference (as an instruction operand, for example), the suffixes “b” (“backward”) or ”f” (“forward”) should be added to the numeric label. It will then refer to the nearest label defined by this number in this direction.
-->
<ul>
<li>まず、ラベルとして同じ数字を複数回、同じインラインブロックで利用できます。</li>
<li>つぎに、数字のラベルが参照として(例えば、命令のオペランドに)利用された場合、&quot;b&quot;(&quot;後方&quot;)や&quot;f&quot;(&quot;前方&quot;)の接尾辞が数字のラベルに追加されなくてはなりません。そうすることで、この数字の指定された方向の最も近いラベルを参照できます。</li>
</ul>
<!--
## Options
-->
<h2 id="オプション"><a class="header" href="#オプション">オプション</a></h2>
<!--
By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However, in many cases it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.
-->
<p>デフォルトでは、インラインアセンブリブロックは、カスタム呼び出し規約をもつ外部のFFI関数呼び出しと同じように扱われます: メモリを読み込んだり書き込んだり、観測可能な副作用を持っていたりするかもしれません。
しかし、多くの場合、アセンブリコードが実際に何をするかという情報を多く与えて、より最適化できる方が望ましいでしょう。</p>
<!--
Let's take our previous example of an `add` instruction:
-->
<p>先ほどの<code>add</code>命令の例を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)] {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(
        &quot;add {0}, {1}&quot;,
        inlateout(reg) a, in(reg) b,
        options(pure, nomem, nostack),
    );
}
assert_eq!(a, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<!--
Options can be provided as an optional final argument to the `asm!` macro. We specified three options here:
- `pure` means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.
- `nomem` means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).
- `nostack` means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.
-->
<p>オプションは<code>asm!</code>マクロの最後の任意引数として渡されます。
ここでは3つのオプションを利用しました:</p>
<ul>
<li><code>pure</code>は、アセンブリコードが観測可能な副作用を持っておらず、出力は入力のみに依存することを意味します。これにより、コンパイラオプティマイザはインラインアセンブリの呼び出し回数を減らしたり、インラインアセンブリを完全に削除したりできます。</li>
<li><code>nomem</code>は、アセンブリコードがメモリの読み書きをしないことを意味します。デフォルトでは、インラインアセンブリはアクセス可能なメモリアドレス(例えばオペランドとして渡されたポインタや、グローバルなど)の読み書きを行うとコンパイラは仮定しています。</li>
<li><code>nostack</code>は、アセンブリコードがスタックにデータをプッシュしないことを意味します。これにより、コンパイラはx86-64のスタックレッドゾーンなどの最適化を利用し、スタックポインタの調整を避けることができます。</li>
</ul>
<!--
These allow the compiler to better optimize code using `asm!`, for example by eliminating pure `asm!` blocks whose outputs are not needed.
-->
<p>これにより、コンパイラは、出力が全く必要とされていない純粋な<code>asm!</code>ブロックを削除するなどして、<code>asm!</code>を使ったコードをより最適化できます。</p>
<!--
See the [reference](../../reference/inline-assembly.html) for the full list of available options and their effects.
-->
<p>利用可能なオプションとその効果の一覧は<a href="https://doc.rust-lang.org/stable/reference/inline-assembly.html">リファレンス</a>を参照してください。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../unsafe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../compatibility.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../unsafe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../compatibility.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
